/**
 * Script to automatically generate code files from actual component sources
 * This reads the actual component files and creates the files array for sections
 */

import fs from "fs";
import path from "path";

const SECTIONS_DIR = path.join(process.cwd(), "src/components/sections");
const OUTPUT_FILE = path.join(process.cwd(), "src/data/section-code-files.ts");

interface ComponentFile {
  id: string;
  name: string;
  language: string;
  code: string;
  path: string;
}

interface SectionCodeFiles {
  [sectionId: string]: ComponentFile[];
}

/**
 * Get the language based on file extension
 */
function getLanguage(filename: string): string {
  const ext = path.extname(filename);
  const languageMap: Record<string, string> = {
    ".tsx": "tsx",
    ".ts": "typescript",
    ".jsx": "jsx",
    ".js": "javascript",
    ".json": "json",
    ".css": "css",
    ".scss": "scss",
    ".md": "markdown",
  };
  return languageMap[ext] || "typescript";
}

/**
 * Recursively get all files in a directory
 */
function getAllFiles(dirPath: string, arrayOfFiles: string[] = []): string[] {
  const files = fs.readdirSync(dirPath);

  files.forEach((file) => {
    const filePath = path.join(dirPath, file);
    if (fs.statSync(filePath).isDirectory()) {
      arrayOfFiles = getAllFiles(filePath, arrayOfFiles);
    } else {
      arrayOfFiles.push(filePath);
    }
  });

  return arrayOfFiles;
}

/**
 * Generate code files for all sections
 */
function generateSectionCodeFiles(): SectionCodeFiles {
  const result: SectionCodeFiles = {};

  // Get all category directories (hero, features, pricing, etc.)
  const categories = fs
    .readdirSync(SECTIONS_DIR)
    .filter((item) => {
      const itemPath = path.join(SECTIONS_DIR, item);
      return fs.statSync(itemPath).isDirectory();
    });

  for (const category of categories) {
    const categoryPath = path.join(SECTIONS_DIR, category);

    // Get all section directories in this category
    const sections = fs
      .readdirSync(categoryPath)
      .filter((item) => {
        const itemPath = path.join(categoryPath, item);
        return fs.statSync(itemPath).isDirectory();
      });

    for (const section of sections) {
      const sectionPath = path.join(categoryPath, section);
      const files = getAllFiles(sectionPath);

      // Filter to only include source files (not test files, etc.)
      const sourceFiles = files.filter((file) => {
        const ext = path.extname(file);
        return (
          [".tsx", ".ts", ".jsx", ".js", ".css", ".scss"].includes(ext) &&
          !file.includes(".test.") &&
          !file.includes(".spec.")
        );
      });

      if (sourceFiles.length > 0) {
        result[section] = sourceFiles.map((filePath, index) => {
          const fileName = path.basename(filePath);
          const relativePath = path.relative(
            path.join(process.cwd(), "src"),
            filePath
          );
          const code = fs.readFileSync(filePath, "utf-8");

          return {
            id: `${section}-file-${index}`,
            name: fileName,
            language: getLanguage(fileName),
            code: code,
            path: relativePath,
          };
        });

        // Add a usage example file
        const componentName = section
          .split("-")
          .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
          .join("");

        result[section].push({
          id: `${section}-usage`,
          name: "page.tsx",
          language: "tsx",
          code: `import { ${componentName} } from "@/components/sections/${category}/${section}/${section}";

export default function Page() {
  return (
    <main>
      <${componentName} />
    </main>
  );
}`,
          path: `app/page.tsx`,
        });
      }
    }
  }

  return result;
}

/**
 * Generate TypeScript file with code files
 */
function generateOutputFile(codeFiles: SectionCodeFiles): void {
  const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by scripts/generate-section-code.ts
 * Run 'npm run generate:section-code' to regenerate
 */

import type { CodeFile } from "./sections-registry";

export const sectionCodeFiles: Record<string, CodeFile[]> = ${JSON.stringify(codeFiles, null, 2)};

/**
 * Get code files for a specific section
 */
export function getCodeFilesForSection(sectionId: string): CodeFile[] | undefined {
  return sectionCodeFiles[sectionId];
}
`;

  fs.writeFileSync(OUTPUT_FILE, content, "utf-8");
  console.log(`‚úÖ Generated section code files at ${OUTPUT_FILE}`);
  console.log(`üìù Total sections: ${Object.keys(codeFiles).length}`);
}

// Run the script
try {
  console.log("üîÑ Generating section code files...");
  const codeFiles = generateSectionCodeFiles();
  generateOutputFile(codeFiles);
  console.log("‚ú® Done!");
} catch (error) {
  console.error("‚ùå Error generating section code files:", error);
  process.exit(1);
}
